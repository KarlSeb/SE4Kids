import os
import subprocess
import argparse
from typing import Dict, Tuple, Optional, List

#Path to the whisker framework
whisker_path = os.path.abspath('./whisker')
#Path where the Sample solutions are stored
solution_path = os.path.abspath('./data/SampleSolutions')
#Path where the Whisker test files are stored
tests_path = os.path.abspath('./data/Tests/js')
#Path where the results of the excution is stored
results_path = os.path.abspath('./data/Results')

def generate_paths(program_name:str, baseline:bool), Dict[str, str]:
    """
    Generates all the paths needed to execute the tests and store the results
    for a specified program_name. Returns the paths in a dictionary.

    Arguments:
        program_name: Name of the program under tes -> str
        baseline: If true changes the tests_path and results_path to the
                    subdirectory /baseline
                  If false tests_path and results_path point to subdirectory
                    /whisker

    Return:
        Dictionary containing the paths to the tested Scratch program, the
        Whisker tests and the Path where the resuls are stored.
    """
    if program_name is None or len(program_name) == 0:
        raise Error("Program name cannot be None or an empty string")

    paths = {}
    sep = '/baseline/' if baseline else '/gpt/'
    paths['scratch_path'] = solution_path + '/' + program_name + '.sb3'
    paths['tests_path'] = tests_path + sep
    if not baseline:
        paths['tests_path'] += program_name + '_Tests.js'
    paths['csv_path'] = results_path + '/csv' + sep + program_name + '_Results.csv'
    return paths

def process_output(output:str) -> str:
    """
    Processes the given string into a readable format by splitting the string
    at the escaped newline characters.

    Arguments:
        output: String to be formatted -> str

    Returns:
        Formatted and readable string.
    """
    output = output.split('\n')
    output = output[0].split('\\n')
    output[0] = output[0][3:]
    output = output[:-1]
    return output

def build_command(program_name:str, csv:bool = True, baseline:bool = False) -> str:
    """
    Builds the command that executes the associated Whisker functionality.
    If baseline is False: The command will run the already existing tests.
    If baseline is True: The command will excute a search to generate tests and
                         execute these tests.

    Arguments:
        program_name: Name of the program under test -> str
        csv: Toggle if results of test execution/generation should be stored in
             a .csv file -> bool
        baseline: Toggle whether Whisker should execute a search or run tests
                  -> bool
    Return:
        String that contains the command to call Whisker
    """
    cmd = ['node', 'servant']
    if baseline:
        cmd.extend(['generate', \
                    '-c', f'{whisker_path}/config/mio.json', \
                    '-r', '10'])
    else:
        cmd.append('run')

    paths = generate_paths(program_name, baseline)
    cmd.extend(['-s', f'{paths["scratch_path"]}', \
                '-t', f'{paths["tests_path"]}'])
    if csv:
        cmd.extend(['-v', f'{paths["csv_path"]}'])

    cmd.extend(['-d', '-a', '10'])
    return cmd

def execute_command(cmd:str, execution_path:str) -> str:
    """
    Executes a command in a new process using the subprocess module and returns
    the output of the process as a string.

    Arguments:
        cmd: command to be executed -> str
        execution_path: Base directory the command is executed in -> str

    Return:
        Output of the process as a string.
    """
    temp = subprocess.Popen(cmd, stdout = subprocess.PIPE, stderr = subprocess.STDOUT, cwd = execution_path)
    return str(temp.communicate())

def get_tests():
    """
    Reads all the program names from the file 'program_names.txt' and returns
    a list of all names.

    Return:
        List of all names.
    """
    names = []
    with open('program_names.txt', 'r') as f:
        names = f.readlines()
    for i in range(len(names)):
        names[i] = names[i].strip()
    return names

def rename_testfile(program_name:str) -> None:
    """
    Renames the test files generated by Whisker to avoid data loss.

    Arguments:
        program_name: Name of the program under test -> str
    """
    old_name = tests_path + '/baseline/tests.js'
    new_name = tests_path + f'/baseline/{program_name}_Tests.js'
    os.rename(old_name, new_name)

def run_all_tests(baseline:bool = False) -> Dict[str, str]:
    """
    Runs or generates tests for all programs specified in program_names.txt and
    returns the output of the processes as a dictionry using the program names
    as a key.

    Arguments:
        baseline: Toggles wether tests should be generated or run.
                  If True: Generates Tests using Whisker
                  If False: Runs existing tests
                  Default: False
                  -> bool
    Return:
        Dictionary containing the output of all the processes as values and the
        program names as keys.
    """
    testable_programs = get_tests()
    output = {}
    for program_name in testable_programs:
        print(f'Running tests for {program_name}')
        cmd = build_command(program_name, baseline=baseline)
        output[program_name] = execute_command(cmd, whisker_path)
        if baseline:
            rename_testfile(program_name)
    return output

def run_test(program_name:str, generate_csv:bool = False, baseline:bool = False) -> str:
    """
    Runs or generates tests for the specified program. The output is the string
    returned by the process.

    Arguments:
        program_name: Name of program under test -> str
        generate_csv: Toggle wether results are stored in a .csv file
                      Default: False
                      -> bool
        baseline: Toggles wether tests should be generated or run.
                  If True: Generates Tests using Whisker
                  If False: Runs existing tests
                  Default: False
                  -> bool
    Return:
        Output of the called process as string.
    """
    testable_programs = get_tests()

    if program_name not in testable_programs:
        raise Error(f"No program with name '{program_name}'!")

    cmd = build_command(program_name, generate_csv, baseline)
    return execute_command(cmd, whisker_path)

def write_output(output: Dict[str, str], baseline:bool = False) -> None:
    """
    Writes the output of the processes into text files.

    Arguments:
        output: Dictionary containing all collected porcess outputs as values and
                program names as keys.
        baseline: Toggles where the text files are stored
                  If True: Stores files in ./data/Results/txt/baseline
                  If False: Stores files in ./data/Results/txt/gpt
    """
    sep = '/txt/baseline/' if baseline else '/txt/gpt/'
    for name in output.keys():
        lines = output[name].split('\\n')
        with open(f'{results_path}{sep}{name}.txt', 'w') as f:
            for line in lines:
                f.write(f'{line}\n')

def parse_command_line_inputs() -> Tuple[Optional[List[str]], bool]:
    """
    Parses the command line inputs and returns the specified names as a list and
    whether the command line option -b was used.
    If -b is used baseline is set to True, otherwise it defaults to False.

    Return:
        A tuple consisting of:
        - A list of all specified names or None if no names were given as arguments
        - A bool value that toggles between the running and generation of tests

    """
    parser = argparse.ArgumentParser(description='Executes the whisker test(s) specified')
    parser.add_argument('-n', '--names', action='extend', type=str, nargs='+', \
                        help='Names of the programs to test. If no names are given all names in program_names.txt are used instead')
    parser.add_argument('-b', dest='baseline', action='store_true', help='generates tests using Whiskers built in MIO')
    parser.set_defaults(baseline=False)
    names = parser.parse_args().names
    baseline = parser.parse_args().baseline
    return names, baseline

def main() -> None:
    """
    Runs or generates tests for the specified programs using the Whisker framework.
    The output of the Whisker processes is stored in text files.
    """
    names, baseline = parse_command_line_inputs()
    output = {}
    if names is None:
        output = run_all_tests(baseline)
    else:
        for name in names:
            print(f'Running tests for {name}')
            output[name] = run_test(name, True, baseline)
            if baseline:
                rename_testfile(name)
    write_output(output, baseline)

if __name__ == '__main__':
    main()
