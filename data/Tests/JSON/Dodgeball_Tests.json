{
  "tests": [
    {
      "name": "Pico walking starts at coordinates (-210, -120)",
      "code": "const testPicoStartCoordinates = async function (t) {\n    t.greenFlag();\n    await t.runUntil(() => {\n        const pico = t.getSprite('Pico walking');\n        return pico.x === -210 && pico.y === -120;\n    }, 5000);\n    t.end();\n}"
    },
    {
      "name": "Pico walking starts with direction 90",
      "code": "const testPicoStartDirection = async function (t) {\n    t.greenFlag();\n    await t.runUntil(() => {\n        const pico = t.getSprite('Pico walking');\n        return pico.direction === 90;\n    }, 5000);\n    t.end();\n}"
    },
    {
      "name": "Global variable gravity starts at -4",
      "code": "const testGravityStart = async function (t) {\n    t.greenFlag();\n    await t.runUntil(() => {\n        const gravity = t.getGlobalVariable('gravity');\n        return gravity === -4;\n    }, 5000);\n    t.end();\n}"
    },
    {
      "name": "Pico walking y coordinate changes by gravity when not touching specific colors",
      "code": "const testPicoGravityEffect = async function (t) {\n    t.greenFlag();\n    await t.runForTime(1000);\n    const pico = t.getSprite('Pico walking');\n    const initialY = pico.y;\n    await t.runForTime(1000);\n    t.assert.not(pico.isTouchingColor([0, 63, 255]) || pico.isTouchingColor([255, 0, 191]), 'Pico is touching forbidden colors');\n    t.assert.equal(pico.y, initialY + t.getGlobalVariable('gravity'), 'Pico y coordinate did not change by gravity');\n    t.end();\n}"
    },
    {
      "name": "Jump height set to 10 when space is pressed and Pico walking is touching specific color",
      "code": "const testJumpHeightSet = async function (t) {\n    t.greenFlag();\n    await t.runForTime(1000);\n    const pico = t.getSprite('Pico walking');\n    await t.runUntil(() => pico.isTouchingColor([0, 63, 255]), 5000);\n    t.keyPress('space');\n    await t.runForTime(1000);\n    t.assert.equal(t.getGlobalVariable('jump height'), 10, 'Jump height not set to 10');\n    t.end();\n}"
    },
    {
      "name": "Jump height decreases by 0.5 until it reaches 0",
      "code": "const testJumpHeightDecrease = async function (t) {\n    t.greenFlag();\n    await t.runForTime(1000);\n    const pico = t.getSprite('Pico walking');\n    await t.runUntil(() => pico.isTouchingColor([0, 63, 255]), 5000);\n    t.keyPress('space');\n    await t.runForTime(1000);\n    let jumpHeight = t.getGlobalVariable('jump height');\n    while (jumpHeight > 0) {\n        await t.runForTime(1000);\n        t.assert.equal(t.getGlobalVariable('jump height'), jumpHeight - 0.5, 'Jump height did not decrease by 0.5');\n        jumpHeight -= 0.5;\n    }\n    t.assert.equal(t.getGlobalVariable('jump height'), 0, 'Jump height did not reach 0');\n    t.end();\n}"
    },
    {
      "name": "Pico walking y coordinate changes by current jump height",
      "code": "const testPicoYChangeByJumpHeight = async function (t) {\n    t.greenFlag();\n    await t.runForTime(1000);\n    const pico = t.getSprite('Pico walking');\n    await t.runUntil(() => pico.isTouchingColor([0, 63, 255]), 5000);\n    t.keyPress('space');\n    await t.runForTime(1000);\n    let jumpHeight = t.getGlobalVariable('jump height');\n    const initialY = pico.y;\n    await t.runForTime(1000);\n    t.assert.equal(pico.y, initialY + jumpHeight, 'Pico y coordinate did not change by jump height');\n    t.end();\n}"
    },
    {
      "name": "Pico walking reset to starting conditions and jump height set to 0 when touched by Ball or Laser",
      "code": "const testPicoResetOnTouch = async function (t) {\n    t.greenFlag();\n    await t.runForTime(1000);\n    const pico = t.getSprite('Pico walking');\n    const ball = t.getSprite('Ball');\n    const laser = t.getSprite('Laser');\n    ball.x = pico.x;\n    ball.y = pico.y;\n    await t.runForTime(1000);\n    t.assert.equal(pico.x, -210, 'Pico x coordinate not reset');\n    t.assert.equal(pico.y, -120, 'Pico y coordinate not reset');\n    t.assert.equal(t.getGlobalVariable('jump height'), 0, 'Jump height not reset to 0');\n    laser.x = pico.x;\n    laser.y = pico.y;\n    await t.runForTime(1000);\n    t.assert.equal(pico.x, -210, 'Pico x coordinate not reset');\n    t.assert.equal(pico.y, -120, 'Pico y coordinate not reset');\n    t.assert.equal(t.getGlobalVariable('jump height'), 0, 'Jump height not reset to 0');\n    t.end();\n}"
    },
    {
      "name": "Pico walking direction is 90 when right arrow key is pressed",
      "code": "const testPicoDirectionRight = async function (t) {\n    t.greenFlag();\n    await t.runForTime(1000);\n    t.keyPress('right arrow');\n    await t.runForTime(1000);\n    const pico = t.getSprite('Pico walking');\n    t.assert.equal(pico.direction, 90, 'Pico direction not 90 when right arrow pressed');\n    t.end();\n}"
    },
    {
      "name": "Pico walking direction is -90 when left arrow key is pressed",
      "code": "const testPicoDirectionLeft = async function (t) {\n    t.greenFlag();\n    await t.runForTime(1000);\n    t.keyPress('left arrow');\n    await t.runForTime(1000);\n    const pico = t.getSprite('Pico walking');\n    t.assert.equal(pico.direction, -90, 'Pico direction not -90 when left arrow pressed');\n    t.end();\n}"
    },
    {
      "name": "Pico walking moves 3 steps when an arrow key is pressed",
      "code": "const testPicoMoveOnArrowPress = async function (t) {\n    t.greenFlag();\n    await t.runForTime(1000);\n    const pico = t.getSprite('Pico walking');\n    const initialX = pico.x;\n    t.keyPress('right arrow');\n    await t.runForTime(1000);\n    t.assert.equal(pico.x, initialX + 3, 'Pico did not move 3 steps when right arrow pressed');\n    t.end();\n}"
    },
    {
      "name": "Pico walking cycles through costumes when an arrow key is pressed",
      "code": "const testPicoCostumeCycleOnArrowPress = async function (t) {\n    t.greenFlag();\n    await t.runForTime(1000);\n    const pico = t.getSprite('Pico walking');\n    const initialCostume = pico.currentCostume;\n    t.keyPress('right arrow');\n    await t.runForTime(1000);\n    t.assert.notEqual(pico.currentCostume, initialCostume, 'Pico did not cycle costumes when right arrow pressed');\n    t.end();\n}"
    },
    {
      "name": "Pico walking y coordinate increases by 4 when touching specific color and up arrow is pressed",
      "code": "const testPicoYIncreaseOnUpArrow = async function (t) {\n    t.greenFlag();\n    await t.runForTime(1000);\n    const pico = t.getSprite('Pico walking');\n    await t.runUntil(() => pico.isTouchingColor([255, 0, 191]), 5000);\n    const initialY = pico.y;\n    t.keyPress('up arrow');\n    await t.runForTime(1000);\n    t.assert.equal(pico.y, initialY + 4, 'Pico y coordinate did not increase by 4 when up arrow pressed');\n    t.end();\n}"
    },
    {
      "name": "Pico walking says ':)' for 2 seconds when touching specific color",
      "code": "const testPicoSayOnTouchColor = async function (t) {\n    t.greenFlag();\n    await t.runForTime(1000);\n    const pico = t.getSprite('Pico walking');\n    await t.runUntil(() => pico.isTouchingColor([0, 204, 68]), 5000);\n    t.assert.equal(pico.sayText, ':)', 'Pico did not say :) when touching specific color');\n    await t.runForTime(2000);\n    t.assert.equal(pico.sayText, '', 'Pico did not stop saying :) after 2 seconds');\n    t.end();\n}"
    },
    {
      "name": "Laser starts with costume 'on'",
      "code": "const testLaserStartCostume = async function (t) {\n    t.greenFlag();\n    await t.runForTime(1000);\n    const laser = t.getSprite('Laser');\n    t.assert.equal(laser.getCostumeByIndex(laser.currentCostume).name, 'on', 'Laser did not start with costume on');\n    t.end();\n}"
    },
    {
      "name": "Laser switches between 'on' and 'off' costumes in random intervals from 2 to 4 seconds",
      "code": "const testLaserCostumeSwitch = async function (t) {\n    t.greenFlag();\n    await t.runForTime(1000);\n    const laser = t.getSprite('Laser');\n    const initialCostume = laser.currentCostume;\n    await t.runForTime(4000);\n    t.assert.notEqual(laser.currentCostume, initialCostume, 'Laser did not switch costumes in 2 to 4 seconds');\n    t.end();\n}"
    },
    {
      "name": "Trapdoor starts with costume 'on'",
      "code": "const testTrapdoorStartCostume = async function (t) {\n    t.greenFlag();\n    await t.runForTime(1000);\n    const trapdoor = t.getSprite('Trapdoor');\n    t.assert.equal(trapdoor.getCostumeByIndex(trapdoor.currentCostume).name, 'on', 'Trapdoor did not start with costume on');\n    t.end();\n}"
    },
    {
      "name": "Trapdoor switches between 'on' and 'off' costumes in random intervals from 3 to 5 seconds",
      "code": "const testTrapdoorCostumeSwitch = async function (t) {\n    t.greenFlag();\n    await t.runForTime(1000);\n    const trapdoor = t.getSprite('Trapdoor');\n    const initialCostume = trapdoor.currentCostume;\n    await t.runForTime(5000);\n    t.assert.notEqual(trapdoor.currentCostume, initialCostume, 'Trapdoor did not switch costumes in 3 to 5 seconds');\n    t.end();\n}"
    },
    {
      "name": "Ball starts invisible",
      "code": "const testBallStartInvisible = async function (t) {\n    t.greenFlag();\n    await t.runForTime(1000);\n    const ball = t.getSprite('Ball');\n    t.assert.equal(ball.visible, false, 'Ball is not invisible at start');\n    t.end();\n}"
    },
    {
      "name": "Ball creates a new clone in random intervals of 3 to 5 seconds",
      "code": "const testBallCloneCreation = async function (t) {\n    t.greenFlag();\n    await t.runForTime(1000);\n    const ball = t.getSprite('Ball');\n    const initialCloneCount = ball.getCloneCount();\n    await t.runForTime(5000);\n    t.assert.greater(ball.getCloneCount(), initialCloneCount, 'Ball did not create a new clone in 3 to 5 seconds');\n    t.end();\n}"
    },
    {
      "name": "Each clone starts with a random size between 30 and 50",
      "code": "const testCloneSize = async function (t) {\n    t.greenFlag();\n    await t.runForTime(1000);\n    const ball = t.getSprite('Ball');\n    await t.runForTime(5000);\n    const clones = ball.getClones();\n    clones.forEach(clone => {\n        t.assert.greaterOrEqual(clone.size, 30, 'Clone size is less than 30');\n        t.assert.lessOrEqual(clone.size, 50, 'Clone size is greater than 50');\n    });\n    t.end();\n}"
    },
    {
      "name": "Each clone starts with a random costume index between 1 and 3",
      "code": "const testCloneCostumeIndex = async function (t) {\n    t.greenFlag();\n    await t.runForTime(1000);\n    const ball = t.getSprite('Ball');\n    await t.runForTime(5000);\n    const clones = ball.getClones();\n    clones.forEach(clone => {\n        t.assert.greaterOrEqual(clone.currentCostume, 1, 'Clone costume index is less than 1');\n        t.assert.lessOrEqual(clone.currentCostume, 3, 'Clone costume index is greater than 3');\n    });\n    t.end();\n}"
    },
    {
      "name": "Each clone starts at coordinates (160, 160)",
      "code": "const testCloneStartCoordinates = async function (t) {\n    t.greenFlag();\n    await t.runForTime(1000);\n    const ball = t.getSprite('Ball');\n    await t.runForTime(5000);\n    const clones = ball.getClones();\n    clones.forEach(clone => {\n        t.assert.equal(clone.x, 160, 'Clone x coordinate is not 160');\n        t.assert.equal(clone.y, 160, 'Clone y coordinate is not 160');\n    });\n    t.end();\n}"
    },
    {
      "name": "Each clone is visible",
      "code": "const testCloneVisibility = async function (t) {\n    t.greenFlag();\n    await t.runForTime(1000);\n    const ball = t.getSprite('Ball');\n    await t.runForTime(5000);\n    const clones = ball.getClones();\n    clones.forEach(clone => {\n        t.assert.equal(clone.visible, true, 'Clone is not visible');\n    });\n    t.end();\n}"
    },
    {
      "name": "Each clone follows a specific movement sequence",
      "code": "const testCloneMovementSequence = async function (t) {\n    t.greenFlag();\n    await t.runForTime(1000);\n    const ball = t.getSprite('Ball');\n    await t.runForTime(5000);\n    const clone = ball.getClones()[0];\n    const initialX = clone.x;\n    const initialY = clone.y;\n    await t.runForTime(1000);\n    t.assert.equal(clone.y, initialY - 4 * 22, 'Clone did not move correctly in first sequence');\n    await t.runForTime(1000);\n    t.assert.equal(clone.x, initialX - 2 * 180, 'Clone did not move correctly in second sequence');\n    await t.runForTime(1000);\n    t.assert.equal(clone.y, initialY - 4 * 30, 'Clone did not move correctly in third sequence');\n    await t.runForTime(1000);\n    t.assert.equal(clone.x, initialX + 2 * 190, 'Clone did not move correctly in fourth sequence');\n    await t.runForTime(1000);\n    t.assert.equal(clone.y, initialY - 4 * 30, 'Clone did not move correctly in fifth sequence');\n    await t.runForTime(1000);\n    t.assert.equal(clone.x, initialX - 2 * 170, 'Clone did not move correctly in sixth sequence');\n    t.end();\n}"
    },
    {
      "name": "Clone is deleted after movement sequence",
      "code": "const testCloneDeletion = async function (t) {\n    t.greenFlag();\n    await t.runForTime(1000);\n    const ball = t.getSprite('Ball');\n    await t.runForTime(5000);\n    const clone = ball.getClones()[0];\n    await t.runForTime(1000);\n    t.assert.equal(clone, undefined, 'Clone was not deleted after movement sequence');\n    t.end();\n}"
    }
  ]
}